---
title: "NEON Macroinvertebrates Data"
author: "Marney Pratt"
date: "10/15/2020"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load libraries 
library(tidyverse)
library(neonUtilities)

```


```{r download all NEON macroinvertebrate data, eval=FALSE, include=FALSE}

###I ran this code once and saved the output, then I turned off running this chunk

# Macroinvert Data Product ID
my_dpid <- 'DP1.20120.001'


# get all tables for these sites from the NEON API 
# Remove token=Sys.getenv("NEON_TOKEN") line if you do not have your own API token for NEON
all_tabs_inv <- neonUtilities::loadByProduct(
  dpID = my_dpid,
  site = 'all',
  package = 'expanded',
  check.size = FALSE,
  token=Sys.getenv("NEON_TOKEN"))

# extract items from list and put in R env. 
all_tabs_inv %>% list2env(.GlobalEnv)


#save readme tibble as csv file
write.csv(readme_20120, "NEONdata/NEON_metadata.csv")

#save file with code definitions
write.csv(categoricalCodes_20120, "NEONdata/categoricalCodes.csv")


```


```{r find wadeable stream sites, eval=FALSE, include=FALSE}

#Run this code to find the wadeable stream sites for 2018-2019, then change the options above so this code chunk isn't run again

# extract year from date, add it as a new column
# filter for streams in 2018-2019
inv_fieldData <- inv_fieldData %>%
  mutate(
    year = collectDate %>% 
      lubridate::as_date() %>% 
      lubridate::year(),
    month = collectDate %>% 
      lubridate::as_date() %>% 
      lubridate::month()) %>% 
  dplyr::filter(aquaticSiteType == "stream",
                year == 2018 |
                year == 2019)

# extract location data into a separate table
NEON_fieldData <- inv_fieldData %>%
  
  # keep only the columns listed below
  select(siteID, 
         domainID,
         namedLocation, 
         decimalLatitude, 
         decimalLongitude, 
         elevation) %>%
  
  # keep rows with unique combinations of values, 
  # i.e., no duplicate records
  distinct()

#Save this data file
write.csv(NEON_fieldData, "NEONdata/NEON_fieldData.csv")

```



```{r  save the macroinvertebrate data for 2018-2019}


# Make the observation table.
# start with inv_taxonomyProcessed
neon.macro <- inv_taxonomyProcessed %>% 
  
  # select a subset of columns from
  # inv_taxonomyProcessed
  select(sampleID,
         domainID,
         siteID,
         collectDate,
         estimatedTotalCount,
         acceptedTaxonID,
         phylum, subphylum, class, subclass, order, family, subfamily, tribe, genus, 
         scientificName,
         taxonRank) %>%
  
  # Join the columns selected above with two 
  # columns from inv_fieldData (the two columns 
  # are sampleID and benthicArea)
  left_join(inv_fieldData %>% 
              select(sampleID, eventID, year, 
                     habitatType, samplerType,
                     benthicArea)) %>%
  
  # some new columns called 'variable_name', 
  # 'value', and 'unit', and assign values for 
  # all rows in the table.
  # variable_name and unit are both assigned the 
  # same text strint for all rows. 
  mutate(inv_dens = estimatedTotalCount / benthicArea,
         inv_dens_unit = 'count per square meter') %>% 

  #filter for years
  dplyr::filter(year == 2018 | year == 2019)


#import master taxa list with tolerance values and FFGs 
neon.mill.taxa <- read_csv("data/neon.mill.taxa.csv")

#merge NEON macro data with master taxa data
neon.mill.taxa2 <- neon.mill.taxa %>%  
  dplyr::select(acceptedTaxonID, organism_aggr, tolerance, FFG, FFG2)

neon.macro <- left_join(neon.macro, neon.mill.taxa2, by="acceptedTaxonID")



write.csv(NEON_fieldData, "NEONdata/neon.macro.csv", 
          row.names = FALSE)

```




